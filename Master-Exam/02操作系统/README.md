# 操作系统Operating System

[toc]

## 第一章 计算机系统概述

### 1.1 操作系统的基本概念

#### 错题

1. 现代操作系统最基本的两个特征是：并发和共享（两者互为存在条件）
2. 操作系统与用户通信接口通常不包括 ~~命令解释器~~ 缓存管理指令
   - 广义指令是系统调用命令，命令解释器属于命令接口，shell是命令解析器，也属于命令接口。
   - 系统中的缓存全部由操作系统管理，对用户透明，不提供管理系统缓存的系统调用。
3. 多道程序设计的基本特征是：制约性，间断性，共享性
   - 引入多道程序设计后，程序就失去了封闭性和顺序性。
   - 因为程序执行需要共享资源和相互协同的原因，相互制约
   - 顺序性是**单道程序设计**的基本特征
4. 说明库函数和系统调用的区别和联系
   - 库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，运行在内核空间中，许多库函数会使用系统调用来实现功能。
   - 未使用系统调用的库函数往往会比使用系统调用的效率高。因为系统调用时需要上下文切换和状态的转换（用户态转向内核态）。
   - Library functions are part of a language or application and can run in user space. System calls, on the other hand, are part of the operating system and run in kernel space, and many library functions will use system calls to implement functionality.
   - Library functions that do not use system calls will often be more efficient than those that do. This is because system calls require context switching and state transitions (user state to kernel state).

### 1.2 操作系统的发展与分类

#### 错题

1. 实时操作系统必须在（~~时间片~~被控制对象规定时间）内处理来自外部的事件。
   - 实时系统要求能实时处理外部事件，即在规定的时间内完成对外部事件的处理。
2. 批处理操作系统、分时操作系统和实时操作系统各有什么特点？
   - 批处理操作系统的用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行，交互能力差
   - 分时操作系统可让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时。
   - 实时操作系统能对控制对象作出及时反应，可靠性高，响应及时，但资源利用率低。

### 1.3 操作系统的运行环境

#### Points

- 陷入（访管）指令仅在用户态下执行。
- 区分用户态和核心态的目的是保护系统程序。

- 用户态到核心态转换发生在中断产生时，核心态到用户态的转换发生在中断返回用户程序时。

#### 错题

1. 下列说法正确的是：
   - 当计算机提供了核心态和用户态时，输入/输出指令必须在核心态下运行。
   - 操作系统中，通道技术是一种硬件技术。I/O通道是一种特殊的处理器，具有执行I/O指令的能力，并且通过执行通道程序来控制I/O操作。
   - 批处理的主要缺点是缺少交互性。
   - 多道性时为了提高系统的利用率和吞吐量而提出的。
2. 中断是操作系统必须提供的功能，因为计算机的各种错误都需要终端处理，核心态与用户态切换也需要中断。
2. 用户程序在用户态下药使用特权指令引起的中断属于访管中断（trap）
2. 核心态到用户态的转换是由操作系统程序执行完成的，用户态到核心态的转换是由**硬件**完成的。
2. 在操作系统中，只能在核心态下执行的指令是广义指令（系统调用命令）。
2. 子程序调用只需保存程序断点，即该指令的下一条指令的地址；终端处理不仅要保存断点（PC的内容），还要保存程序状态字寄存器（PSWR）的内容。在中断处理中最重要的两个寄存器就是PC和PSWR。

### 1.4 操作系统的体系结构

#### 错题

微内核的好处：1.添加系统服务时，可以不必修改内核。2.使系统更可靠。

## 第二章 进程管理

### 2.1 进程与线程

#### 错题

1. 进程获得处理器运行是通过调度得到的
2. 动态性是进程最重要的特性。
3. 系统发生死锁时，可能所有的进程都在阻塞态。
4. 申请处理器得不到满足时就处于就绪态，等待处理器调度。
5. 一个进程的基本状态可以从其他两种基本状态转变过去，这个基本的状态是就绪态。时间片到，运行态变为就绪态；当所需资源到达时，进程由阻塞态转换为就绪态。
6. 进程在处理器上执行时，进程之间可能是无关的，但也有可能是有交互性的。
7. 不管系统中是否有线程，进程都是拥有资源的独立单位，线程本身不具有资源，它可以共享所属进程的全部资源。线程是调度的基本单位，因此线程可以并发执行。在用户级线程中，有关线程的管理工作全部由应用程序完成，内核意识不到线程的存在。
8. C语言编写的程序一般分三个段
   - 正文段：二进制代码和常量存放在正文段
   - 数据堆段：动态分配的存储区存放在堆
   - 数据栈段：临时使用的变量在栈（未赋值的局部变量和实参传递）
9. 进程创建原语完成的工作是：向系统申请一个空闲的PCB，为被创建的进程分配必要的资源，后将PCB初始化，然后将PCB插入到就绪队列，返回一个进程标识号。当调度程序为进程分配CPU后，进程开始运行。所以进程创建的过程中不会包括分配CPU的过程，这不是进程创建者的工作，这是调度程序的工作。

### 2.2 处理机调度

#### 错题

1. 先来先服务（FCFS）调度算法是一种最简单的调度算法，比较有利于长作业，不利于短作业。CPU繁忙型作业更接近于长作业。
2. 响应比=$\frac{响应时间}{要求服务时间}=\frac{等待时间+要求服务时间}{要求服务时间}$
2. 时间片轮转算法是按固定的时间配额来运行的，时间一到不管是否完成，当前的进程撤下，调度新的进程，因此它是由时间配额决定的，是绝对可抢占的。
2. **作业与进程的区别**：作业是从用户角度出发，以用户任务为单位，进程是从操作系统出发的，由系统生成，是操作系统资源分配和独立运行的基本单位。
2. 先来先服务算法中，若长进程/作业到达系统，则会使后面许多短进程/作业得不到处理机。
2. 1⃣️分时系统中，响应时间与时间片和用户数成正比。2⃣️中断向量本身是用于存放中断服务程序的入口地址，中断向量地址就是中断向量地址的地址。3⃣️中断有硬件保护并完成，主要是为了保证系统运行可靠、正确，提高速度并不是主要目的。
2. Q：为什么多级反馈队列调度算法能够较好地满足各类用户的需要。A：对终端型用户而言，作业多为交互型作业，比较短小。系统只要能使作业在第一队列处理结束，那么就会使用户感到满意。对短批处理用户而言，较短的作业就像终端型用户一样，很快可以得到解决，较长的作业也会在2-3队列中执行一个时间片就可以解决，总体周转时间仍然较短。对长批处理用户来说，作业会依次在1，2，...，n队列中运行，然后按时间片轮转运行，也不必担心得不到处理。

### 2.3 进程同步

#### 错题

1. 不需要信号量就能实现的功能是：进程的并发执行。信号量机制是用来实现进程的同步和互斥的。

2. 所谓临界区就是指访问临界资源的那段代码程序，如P/V操作、加减锁。操作系统访问临界资源时关心的是临界区的操作过程，具体是对临界资源做什么操作，操作系统并不关心。

3. 并发进程因为共享资源而产生相互之间的制约关系，可以分为两类：1⃣️**互斥关系**：指进程之间因为相互竞争使用独占型资源所产生的制约关系。2⃣️**同步关系**：指进程之间为协同工作需要交换信息，相互等待而产生的制约关系。

4.  **管程**是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和进程同步。管程不仅能实现进程间的互斥，而且能实现进程间的同步。一个进程只有通过调用管程内的过程才能进入管程访问共享数据。**定义：**一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。由定义可知，管程由三部分组成：1.局部于管程的共享变量说明。2.该数据结构进行操作的一组过程。3.对局部于管程的数据设置初始值的语句，此外，还需为该管程赋予一个名字。改成的引入是为了解决临界区分散带来的管理和控制问题。

5. **Peterson算法：**为了防止两个进程为进入临界区而无限期等待，设置了变量`turn`表示允许进入临界区的编号。每个进程在先设置自己的标志后再设置`turn`标志，允许另一个进程进入。这时，再同时检测另一个进程状态标志和允许进入标志，就可以保证两个进程同时要求进入临界区时只允许一个进程进入。保存的事较晚一次复制，因此较晚的进程等待，较早的进程进入。先到先入，后到等待。

6. 信箱通信是一种间接通信方式。

7. 哲学家进餐问题：

   ```c
   semaphore chopstick[5] = {1, 1, 1, 1, 1}//定义信号量数组并初始化
   semaphore mutex = 1;//设置取筷子的信号量
   Pi() {
   	do {
   		P(mutex);
   		P(chopstick[i]);
   		P(chopstick[(i+1)%5]);
   		V(mutex);
   		eat;
   		V(chopstick[i]);
   		V(chopstick[(i+1)%5];
   		think;
   	} while(1);
   }
   ```

7. 

### 2.4 死锁

#### 错题

1. 发生死锁的四个必要条件：互斥、占有并请求、非剥夺、和循环等待。
	- 互斥：进程要求对所分配的资源（如打印机）进程排他性控制，即在一段时间内某资源仅为一个进程所有。此时若其他进程请求该资源，则请求进程只能等待。
	- 非剥夺：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，只能由获得该资源的进程自己释放。
	- 请求并保持（占有并请求）：进程已经保持了至少一个资源，但是又提出新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己已经获得的资源保持不放。
	- 循环等待：存在一种进程资源的循环等待链。
2. 解除死锁的方法有1.剥夺资源法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。2.撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。3.进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非剥夺。
2. 死锁检测一般采用两种方法：资源有向图和资源矩阵法。
3. 不安全状态包括死锁状态
4. 产生死锁的两个根本原因：系统资源分配不足，进程推进顺序非法。
5. 资源的有序分配策略可以破坏死锁的循环等待条件。
7. 死锁的处理策略：预防死锁、避免死锁、死锁的检测与解除。
   - 预防死锁：设置某些限制条件，破坏一个或者多个发生死锁的必要条件。
   - 在资源动态分配的过程中，用某种方法防止系统进入不安全状态。
   - 死锁的检测与解除：允许发生死锁，通过系统的检测机构检测并且及时的解除。
6. 

## 第三章 内存管理

### 3.1 内存管理概念

#### 错题

### 3.2 虚拟内存管理

#### 错题

## 第四章 文件管理

### 4.1 文件系统基础

#### 错题

### 4.2 文件系统实现

#### 错题

### 4.3 磁盘组织与管理

#### 错题

## 第五章 输入/输出（I/O）管理

### 5.1 I/O管理概述

#### 错题

### 5.2 I/O核心子系统

#### 错题
